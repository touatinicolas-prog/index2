<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon.png">

    <link rel="manifest" href="manifest.json">
    
    <title>Mon Index Biblique</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --accent: #4a90e2;
            --border: #4a4a4a;
            --success: #2d7d46;
            --warning: #e67e22;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-user-select: none;
            user-select: none;
        }
        .header {
            background: var(--bg-secondary);
            padding: 20px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .header h1 { font-size: 22px; font-weight: 600; }
        .header-buttons { display: flex; gap: 8px; }
        .mode-toggle, .sync-btn, .settings-btn {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            -webkit-tap-highlight-color: transparent;
        }
        .settings-btn { background: var(--bg-tertiary); padding: 8px 12px; }
        .sync-btn { padding: 8px 12px; }
        .sync-status {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 10px;
        }
        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }
        .sync-indicator.synced { background: var(--success); }
        .sync-indicator.syncing { background: var(--warning); animation: pulse 1s infinite; }
        .sync-indicator.error { background: #e74c3c; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .search-input {
            width: 100%;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 12px;
            -webkit-user-select: text;
            user-select: text;
        }
        .controls { display: flex; gap: 8px; flex-wrap: wrap; }
        .controls.hidden { display: none; }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            flex: 1;
            min-width: 100px;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-success { background: #2d7d46; color: white; }
        .btn-info { background: #357abd; color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); }
        .container { padding-bottom: 40px; }
        .category-card { background: var(--bg-secondary); border-bottom: 1px solid var(--border); }
        .category-card.dragging { opacity: 0.5; }
        .category-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .category-title-wrapper { display: flex; align-items: center; gap: 12px; flex: 1; }
        .category-title { font-size: 18px; font-weight: 600; }
        .drag-handle {
            cursor: grab;
            padding: 4px 8px;
            user-select: none;
            font-size: 18px;
            -webkit-tap-highlight-color: transparent;
        }
        .drag-handle:active { cursor: grabbing; }
        .icon-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 4px 8px;
            -webkit-tap-highlight-color: transparent;
        }
        .icon-btn.hidden { display: none; }
        .chevron { color: var(--text-secondary); font-size: 14px; }
        .category-content { display: none; background: var(--bg-primary); }
        .category-content.expanded { display: block; }
        .subcategory { 
            padding: 16px 20px 16px 40px; 
            border-bottom: 1px solid var(--border);
            position: relative;
        }
        .subcategory.level-2 { padding-left: 60px; }
        .subcategory.dragging { opacity: 0.5; }
        .subcategory.drag-over { border-top: 3px solid var(--accent); }
        .subcategory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .subcategory-title-wrapper { display: flex; align-items: center; gap: 10px; flex: 1; }
        .subcategory-title { font-size: 16px; font-weight: 500; color: var(--accent); }
        .count-badge {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 8px;
        }
        .subcategory-content { display: none; margin-top: 8px; }
        .subcategory-content.expanded { display: block; }
        .verse-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .verse-item.dragging { opacity: 0.5; }
        .verse-item.drag-over { border-top: 2px solid var(--accent); }
        .verse-content { flex: 1; display: flex; align-items: flex-start; gap: 8px; }
        .verse-ref {
            color: var(--accent);
            font-weight: 500;
            text-decoration: none;
            -webkit-tap-highlight-color: transparent;
        }
        .verse-ref:hover { text-decoration: underline; }
        .verse-note {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            -webkit-user-select: text;
            user-select: text;
        }
        .verse-actions { display: flex; gap: 6px; }
        .verse-actions button { font-size: 16px; }
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-title { font-size: 20px; font-weight: 600; }
        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }
        .form-group {
            margin-bottom: 16px;
        }
        .form-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        .form-input, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            -webkit-user-select: text;
            user-select: text;
        }
        .form-textarea { 
            min-height: 100px; 
            resize: vertical;
            line-height: 1.4;
        }
        .form-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        .empty-state-icon { font-size: 48px; margin-bottom: 16px; }
        .empty-state-text { font-size: 16px; }
        .subcategory-controls {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }
        .subcategory-controls button { flex: 1; }
        .subcategory-controls.hidden { display: none; }
        .attachment-list {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .attachment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        .attachment-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 14px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
        }
        .attachment-link:hover { text-decoration: underline; }
        .attachment-delete {
            background: transparent;
            border: none;
            color: #e74c3c;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            -webkit-tap-highlight-color: transparent;
        }
        @media (max-width: 600px) {
            .header { padding: 16px; }
            .header h1 { font-size: 20px; }
            .btn { min-width: 80px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-top">
            <h1>📖 Mon Index Biblique</h1>
            <div class="header-buttons">
                <button class="sync-btn" onclick="handleSync()" title="Synchroniser">🔄</button>
                <button class="settings-btn" onclick="toggleMode()" title="Mode édition">⚙️</button>
            </div>
        </div>
        <div class="sync-status">
            <span class="sync-indicator" id="syncIndicator"></span>
            <span id="syncMessage">Chargement...</span>
        </div>
        <input type="text" class="search-input" id="searchInput" placeholder="Rechercher...">
        <div class="controls hidden" id="controls">
            <button class="btn btn-primary" onclick="openAddCategoryModal()">+ Catégorie</button>
            <button class="btn btn-success" onclick="exportData()">💾 Exporter</button>
            <button class="btn btn-info" onclick="importData()">📂 Importer</button>
        </div>
    </div>

    <div class="container" id="container">
        <div class="empty-state">
            <div class="empty-state-icon">📚</div>
            <div class="empty-state-text">Chargement de vos données...</div>
        </div>
    </div>

    <div class="modal" id="categoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="categoryModalTitle">Nouvelle catégorie</h2>
                <button class="modal-close" onclick="closeModal('categoryModal')">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label">Nom de la catégorie</label>
                <input type="text" class="form-input" id="categoryNameInput">
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" onclick="closeModal('categoryModal')">Annuler</button>
                <button class="btn btn-primary" onclick="saveCategory()">Enregistrer</button>
            </div>
        </div>
    </div>

    <div class="modal" id="subcategoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="subcategoryModalTitle">Nouvelle sous-catégorie</h2>
                <button class="modal-close" onclick="closeModal('subcategoryModal')">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label">Nom de la sous-catégorie</label>
                <input type="text" class="form-input" id="subcategoryNameInput">
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" onclick="closeModal('subcategoryModal')">Annuler</button>
                <button class="btn btn-primary" onclick="saveSubcategory()">Enregistrer</button>
            </div>
        </div>
    </div>

    <div class="modal" id="verseModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="verseModalTitle">Nouveau verset</h2>
                <button class="modal-close" onclick="closeModal('verseModal')">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label">Référence</label>
                <input type="text" class="form-input" id="verseRefInput" placeholder="Ex: Jean 3:16">
            </div>
            <div class="form-group">
                <label class="form-label">Note</label>
                <textarea class="form-textarea" id="verseNoteInput"></textarea>
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" onclick="closeModal('verseModal')">Annuler</button>
                <button class="btn btn-primary" onclick="saveVerse()">Enregistrer</button>
            </div>
        </div>
    </div>

    <input type="file" id="importInput" accept=".json" style="display:none">

    <script>
        let data = { categories: [] };
        let editMode = false;
        let searchTerm = '';
        let currentEditId = null;
        let currentCategoryId = null;
        let currentSubcategoryId = null;
        let currentSubcategoryPath = null;
        let draggedItem = null;
        let touchStartY = 0;
        let touchStartX = 0;
        let isDragging = false;

        // Synchronisation Google Drive
        let syncStatus = 'loading';
        const GOOGLE_CLIENT_ID = 'VOTRE_CLIENT_ID.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'VOTRE_API_KEY';
        const DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        
        let gapiInited = false;
        let gisInited = false;
        let tokenClient;
        let accessToken = null;
        let fileId = null;

        function updateSyncStatus(status, message) {
            syncStatus = status;
            const indicator = document.getElementById('syncIndicator');
            const messageEl = document.getElementById('syncMessage');
            
            indicator.className = 'sync-indicator';
            if (status === 'synced') indicator.classList.add('synced');
            else if (status === 'syncing') indicator.classList.add('syncing');
            else if (status === 'error') indicator.classList.add('error');
            
            messageEl.textContent = message;
        }

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: GOOGLE_API_KEY,
                    discoveryDocs: DISCOVERY_DOCS,
                });
                gapiInited = true;
                maybeEnableSync();
            } catch (error) {
                console.error('Erreur initialisation GAPI:', error);
                updateSyncStatus('error', 'Erreur de connexion');
            }
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: SCOPES,
                callback: '',
            });
            gisInited = true;
            maybeEnableSync();
        }

        function maybeEnableSync() {
            if (gapiInited && gisInited) {
                updateSyncStatus('ready', 'Prêt à synchroniser');
                loadLocalData();
            }
        }

        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    throw (resp);
                }
                accessToken = gapi.client.getToken();
                await syncWithDrive();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({prompt: 'consent'});
            } else {
                tokenClient.requestAccessToken({prompt: ''});
            }
        }

        async function syncWithDrive() {
            if (!accessToken) {
                handleAuthClick();
                return;
            }

            updateSyncStatus('syncing', 'Synchronisation...');

            try {
                if (!fileId) {
                    const searchResponse = await gapi.client.drive.files.list({
                        q: "name='bible_index_data.json' and mimeType='application/json'",
                        spaces: 'drive',
                        fields: 'files(id, name, modifiedTime)',
                    });

                    if (searchResponse.result.files && searchResponse.result.files.length > 0) {
                        fileId = searchResponse.result.files[0].id;
                    }
                }

                if (fileId) {
                    const fileResponse = await gapi.client.drive.files.get({
                        fileId: fileId,
                        alt: 'media'
                    });

                    const driveData = fileResponse.result;
                    const localLastModified = Math.max(...getAllLastModified(data));
                    const driveLastModified = Math.max(...getAllLastModified(driveData));

                    if (driveLastModified > localLastModified) {
                        data = driveData;
                        saveData();
                        render();
                        updateSyncStatus('synced', 'Synchronisé ✓');
                    } else {
                        await uploadToDrive();
                    }
                } else {
                    await uploadToDrive();
                }
            } catch (error) {
                console.error('Erreur de synchronisation:', error);
                updateSyncStatus('error', 'Erreur de sync');
            }
        }

        async function uploadToDrive() {
            const content = JSON.stringify(data, null, 2);
            const file = new Blob([content], { type: 'application/json' });
            const metadata = {
                name: 'bible_index_data.json',
                mimeType: 'application/json',
            };

            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', file);

            try {
                const response = await fetch(
                    `https://www.googleapis.com/upload/drive/v3/files${fileId ? '/' + fileId : ''}?uploadType=multipart`,
                    {
                        method: fileId ? 'PATCH' : 'POST',
                        headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                        body: form,
                    }
                );

                const result = await response.json();
                fileId = result.id;
                updateSyncStatus('synced', 'Synchronisé ✓');
            } catch (error) {
                console.error('Erreur upload:', error);
                updateSyncStatus('error', 'Erreur upload');
            }
        }

        function getAllLastModified(obj) {
            let dates = [];
            if (obj.lastModified) dates.push(obj.lastModified);
            if (obj.categories) {
                obj.categories.forEach(cat => {
                    dates = dates.concat(getAllLastModified(cat));
                });
            }
            if (obj.subcategories) {
                obj.subcategories.forEach(sub => {
                    dates = dates.concat(getAllLastModified(sub));
                });
            }
            if (obj.verses) {
                obj.verses.forEach(verse => {
                    if (verse.lastModified) dates.push(verse.lastModified);
                });
            }
            return dates;
        }

        function handleSync() {
            if (accessToken) {
                syncWithDrive();
            } else {
                handleAuthClick();
            }
        }

        function loadLocalData() {
            const saved = localStorage.getItem('bibleIndexData');
            if (saved) {
                try {
                    data = JSON.parse(saved);
                    updateSyncStatus('local', 'Données locales');
                } catch (e) {
                    console.error('Erreur lecture données:', e);
                    updateSyncStatus('error', 'Erreur chargement');
                }
            } else {
                updateSyncStatus('local', 'Aucune donnée');
            }
            render();
        }

        function saveData() {
            localStorage.setItem('bibleIndexData', JSON.stringify(data));
        }

        function toggleMode() {
            editMode = !editMode;
            document.getElementById('controls').classList.toggle('hidden', !editMode);
            render();
        }

        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            currentEditId = null;
            currentCategoryId = null;
            currentSubcategoryId = null;
            currentSubcategoryPath = null;
        }

        function openAddCategoryModal() {
            currentEditId = null;
            document.getElementById('categoryModalTitle').textContent = 'Nouvelle catégorie';
            document.getElementById('categoryNameInput').value = '';
            openModal('categoryModal');
        }

        function openEditCategoryModal(id) {
            const cat = data.categories.find(c => c.id === id);
            if (!cat) return;
            currentEditId = id;
            document.getElementById('categoryModalTitle').textContent = 'Modifier la catégorie';
            document.getElementById('categoryNameInput').value = cat.name;
            openModal('categoryModal');
        }

        function saveCategory() {
            const name = document.getElementById('categoryNameInput').value.trim();
            if (!name) return;

            if (currentEditId) {
                const cat = data.categories.find(c => c.id === currentEditId);
                if (cat) {
                    cat.name = name;
                    cat.lastModified = Date.now();
                }
            } else {
                data.categories.push({
                    id: Date.now(),
                    name: name,
                    expanded: false,
                    subcategories: [],
                    lastModified: Date.now()
                });
            }

            saveData();
            render();
            closeModal('categoryModal');
        }

        function deleteCategory(id) {
            if (confirm('Supprimer cette catégorie et tout son contenu ?')) {
                data.categories = data.categories.filter(c => c.id !== id);
                saveData();
                render();
            }
        }

        function toggleCategory(id, event) {
            // Empêcher la propagation si on clique sur un bouton
            if (event && (event.target.tagName === 'BUTTON' || event.target.closest('button'))) {
                return;
            }
            
            const cat = data.categories.find(c => c.id === id);
            if (cat) {
                cat.expanded = !cat.expanded;
                cat.lastModified = Date.now();
                saveData();
                render();
            }
        }

        function openAddSubcategoryModal(catId, subId = null, path = null) {
            currentCategoryId = catId;
            currentSubcategoryId = subId;
            currentSubcategoryPath = path;
            currentEditId = null;
            document.getElementById('subcategoryModalTitle').textContent = 'Nouvelle sous-catégorie';
            document.getElementById('subcategoryNameInput').value = '';
            openModal('subcategoryModal');
        }

        function openEditSubcategoryModal(catId, subId) {
            const sub = findSub(catId, subId);
            if (!sub) return;
            currentCategoryId = catId;
            currentSubcategoryId = null;
            currentEditId = subId;
            document.getElementById('subcategoryModalTitle').textContent = 'Modifier la sous-catégorie';
            document.getElementById('subcategoryNameInput').value = sub.name;
            openModal('subcategoryModal');
        }

        function saveSubcategory() {
            const name = document.getElementById('subcategoryNameInput').value.trim();
            if (!name) return;

            if (currentEditId) {
                const sub = findSub(currentCategoryId, currentEditId);
                if (sub) {
                    sub.name = name;
                    sub.lastModified = Date.now();
                }
            } else {
                const newSub = {
                    id: Date.now(),
                    name: name,
                    expanded: false,
                    verses: [],
                    subcategories: [],
                    lastModified: Date.now()
                };

                if (currentSubcategoryPath) {
                    const parent = getSubcategoryByPath(currentCategoryId, currentSubcategoryPath);
                    if (parent && parent.data) {
                        parent.data.subcategories.push(newSub);
                    }
                } else {
                    const cat = data.categories.find(c => c.id === currentCategoryId);
                    if (cat) {
                        cat.subcategories.push(newSub);
                    }
                }
            }

            saveData();
            render();
            closeModal('subcategoryModal');
        }

        function deleteSubcategory(catId, subId) {
            if (confirm('Supprimer cette sous-catégorie et tout son contenu ?')) {
                const cat = data.categories.find(c => c.id === catId);
                if (cat) {
                    removeSubById(cat.subcategories, subId);
                    cat.lastModified = Date.now();
                    saveData();
                    render();
                }
            }
        }

        function toggleSubcategory(catId, subId, event) {
            // Empêcher la propagation si on clique sur un bouton
            if (event && (event.target.tagName === 'BUTTON' || event.target.closest('button'))) {
                return;
            }
            
            const sub = findSub(catId, subId);
            if (sub) {
                sub.expanded = !sub.expanded;
                sub.lastModified = Date.now();
                saveData();
                render();
            }
        }

        function openAddVerseModal(catId, subId) {
            currentCategoryId = catId;
            currentSubcategoryId = subId;
            currentEditId = null;
            document.getElementById('verseModalTitle').textContent = 'Nouveau verset';
            document.getElementById('verseRefInput').value = '';
            document.getElementById('verseNoteInput').value = '';
            openModal('verseModal');
        }

        function openEditVerseModal(catId, subId, verseId) {
            const sub = findSub(catId, subId);
            if (!sub) return;
            const verse = sub.verses.find(v => v.id === verseId);
            if (!verse) return;

            currentCategoryId = catId;
            currentSubcategoryId = subId;
            currentEditId = verseId;
            document.getElementById('verseModalTitle').textContent = 'Modifier le verset';
            document.getElementById('verseRefInput').value = verse.ref;
            document.getElementById('verseNoteInput').value = verse.note || '';
            openModal('verseModal');
        }

        function saveVerse() {
            const ref = document.getElementById('verseRefInput').value.trim();
            const note = document.getElementById('verseNoteInput').value.trim();
            if (!ref) return;

            const sub = findSub(currentCategoryId, currentSubcategoryId);
            if (!sub) return;

            if (currentEditId) {
                const verse = sub.verses.find(v => v.id === currentEditId);
                if (verse) {
                    verse.ref = ref;
                    verse.note = note;
                    verse.lastModified = Date.now();
                }
            } else {
                sub.verses.push({
                    id: Date.now(),
                    ref: ref,
                    note: note,
                    attachments: [],
                    lastModified: Date.now()
                });
            }

            sub.lastModified = Date.now();
            saveData();
            render();
            closeModal('verseModal');
        }

        function deleteVerse(catId, subId, verseId) {
            if (confirm('Supprimer ce verset ?')) {
                const sub = findSub(catId, subId);
                if (sub) {
                    sub.verses = sub.verses.filter(v => v.id !== verseId);
                    sub.lastModified = Date.now();
                    saveData();
                    render();
                }
            }
        }

        function findSub(catId, subId) {
            const cat = data.categories.find(c => c.id === catId);
            if (!cat) return null;
            return findSubRecursive(cat.subcategories, subId);
        }

        function findSubRecursive(subs, subId) {
            for (const sub of subs) {
                if (sub.id === subId) return sub;
                const found = findSubRecursive(sub.subcategories || [], subId);
                if (found) return found;
            }
            return null;
        }

        function removeSubById(subs, subId) {
            for (let i = 0; i < subs.length; i++) {
                if (subs[i].id === subId) {
                    subs.splice(i, 1);
                    return true;
                }
                if (removeSubById(subs[i].subcategories || [], subId)) {
                    return true;
                }
            }
            return false;
        }

        function getSubcategoryByPath(catId, path) {
            const cat = data.categories.find(c => c.id === catId);
            if (!cat) return null;

            const indices = path.split('-').map(Number);
            let current = cat.subcategories;
            let parent = cat.subcategories;

            for (let i = 0; i < indices.length; i++) {
                const idx = indices[i];
                if (i === indices.length - 1) {
                    return { data: current[idx], parent: parent, index: idx };
                }
                parent = current[idx].subcategories;
                current = current[idx].subcategories;
            }
            return null;
        }

        function exportData() {
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bible-index-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            document.getElementById('importInput').click();
        }

        document.getElementById('importInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const imported = JSON.parse(event.target.result);
                    if (confirm('Remplacer toutes les données actuelles ?')) {
                        data = imported;
                        saveData();
                        render();
                    }
                } catch (error) {
                    alert('Erreur lors de l\'import du fichier');
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchTerm = e.target.value.toLowerCase();
            render();
        });

        function matchesSearch(text) {
            return !searchTerm || text.toLowerCase().includes(searchTerm);
        }

        function countMatchingVerses(sub) {
            let count = 0;
            if (sub.verses) {
                count += sub.verses.filter(v => 
                    matchesSearch(v.ref) || matchesSearch(v.note || '')
                ).length;
            }
            if (sub.subcategories) {
                sub.subcategories.forEach(s => {
                    count += countMatchingVerses(s);
                });
            }
            return count;
        }

        function render() {
            const container = document.getElementById('container');
            
            if (data.categories.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📚</div>
                        <div class="empty-state-text">Aucune catégorie. Activez le mode édition pour commencer.</div>
                    </div>
                `;
                return;
            }

            let html = '';
            data.categories.forEach(cat => {
                const matchingSubs = cat.subcategories.filter(sub => 
                    matchesSearch(sub.name) || countMatchingVerses(sub) > 0
                );

                if (searchTerm && matchingSubs.length === 0 && !matchesSearch(cat.name)) {
                    return;
                }

                const isExpanded = cat.expanded || searchTerm;
                html += `
                    <div class="category-card" data-cat-id="${cat.id}">
                        <div class="category-header" onclick="toggleCategory(${cat.id}, event)">
                            <div class="category-title-wrapper">
                                ${editMode ? `<span class="drag-handle" data-cat-id="${cat.id}">☰</span>` : ''}
                                <span class="category-title">${cat.name}</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <button class="icon-btn ${editMode ? '' : 'hidden'}" onclick="event.stopPropagation(); openEditCategoryModal(${cat.id})" title="Modifier">✏️</button>
                                <button class="icon-btn ${editMode ? '' : 'hidden'}" onclick="event.stopPropagation(); deleteCategory(${cat.id})" title="Supprimer">🗑️</button>
                                <span class="chevron">${isExpanded ? '▼' : '▶'}</span>
                            </div>
                        </div>
                        <div class="category-content ${isExpanded ? 'expanded' : ''}">
                            ${editMode ? `
                                <div style="padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);">
                                    <button class="btn btn-primary" onclick="openAddSubcategoryModal(${cat.id})" style="width: 100%;">+ Sous-catégorie</button>
                                </div>
                            ` : ''}
                            ${renderSubcategories(cat.id, cat.subcategories, 1, '')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            setupDragAndDrop();
        }

        function renderSubcategories(catId, subs, level, parentPath) {
            if (!subs || subs.length === 0) return '';

            return subs.map((sub, index) => {
                const currentPath = parentPath ? `${parentPath}-${index}` : `${index}`;
                const matchingVerses = sub.verses?.filter(v => 
                    matchesSearch(v.ref) || matchesSearch(v.note || '')
                ) || [];
                
                const childMatchCount = countMatchingVerses(sub);
                
                if (searchTerm && childMatchCount === 0 && !matchesSearch(sub.name)) {
                    return '';
                }

                const isExpanded = sub.expanded || (searchTerm && childMatchCount > 0);
                const verseCount = (sub.verses?.length || 0) + (sub.subcategories?.reduce((sum, s) => sum + countMatchingVerses(s), 0) || 0);

                return `
                    <div class="subcategory level-${level}" 
                         data-cat-id="${catId}" 
                         data-sub-id="${sub.id}" 
                         data-sub-path="${currentPath}"
                         data-level="${level}">
                        <div class="subcategory-header" onclick="toggleSubcategory(${catId}, ${sub.id}, event)">
                            <div class="subcategory-title-wrapper">
                                ${editMode ? `<span class="drag-handle">☰</span>` : ''}
                                <span class="subcategory-title">${sub.name}</span>
                                ${verseCount > 0 ? `<span class="count-badge">${verseCount}</span>` : ''}
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <button class="icon-btn ${editMode ? '' : 'hidden'}" onclick="event.stopPropagation(); openEditSubcategoryModal(${catId}, ${sub.id})" title="Modifier">✏️</button>
                                <button class="icon-btn ${editMode ? '' : 'hidden'}" onclick="event.stopPropagation(); deleteSubcategory(${catId}, ${sub.id})" title="Supprimer">🗑️</button>
                                <span class="chevron">${isExpanded ? '▼' : '▶'}</span>
                            </div>
                        </div>
                        <div class="subcategory-content ${isExpanded ? 'expanded' : ''}">
                            ${editMode ? `
                                <div class="subcategory-controls">
                                    <button class="btn btn-primary" onclick="openAddVerseModal(${catId}, ${sub.id})">+ Verset</button>
                                    ${level < 2 ? `<button class="btn btn-info" onclick="openAddSubcategoryModal(${catId}, ${sub.id}, '${currentPath}')">+ Sous-catégorie</button>` : ''}
                                </div>
                            ` : ''}
                            ${renderVerses(catId, sub.id, matchingVerses)}
                            ${level < 2 ? renderSubcategories(catId, sub.subcategories || [], level + 1, currentPath) : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderVerses(catId, subId, verses) {
            if (!verses || verses.length === 0) return '';

            return verses.map((verse, index) => `
                <div class="verse-item" 
                     data-cat-id="${catId}" 
                     data-sub-id="${subId}" 
                     data-verse-id="${verse.id}"
                     data-verse-index="${index}">
                    <div class="verse-content">
                        ${editMode ? `<span class="drag-handle">☰</span>` : ''}
                        <div style="flex: 1;">
                            <a href="#" class="verse-ref" onclick="event.preventDefault(); openJWVerse('${verse.ref.replace(/'/g, "\\'")}')">
                                ${verse.ref}
                            </a>
                            ${verse.note ? `<div class="verse-note">${verse.note}</div>` : ''}
                            ${verse.attachments && verse.attachments.length > 0 ? `
                                <div class="attachment-list">
                                    ${verse.attachments.map((att, i) => `
                                        <div class="attachment-item">
                                            <a href="${att.url}" target="_blank" class="attachment-link">📎 ${att.name}</a>
                                            ${editMode ? `<button class="attachment-delete" onclick="deleteAttachment(${catId}, ${subId}, ${verse.id}, ${i})">×</button>` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    <div class="verse-actions ${editMode ? '' : 'hidden'}">
                        <button class="icon-btn" onclick="openEditVerseModal(${catId}, ${subId}, ${verse.id})" title="Modifier">✏️</button>
                        <button class="icon-btn" onclick="deleteVerse(${catId}, ${subId}, ${verse.id})" title="Supprimer">🗑️</button>
                    </div>
                </div>
            `).join('');
        }

        function deleteAttachment(catId, subId, verseId, attIndex) {
            const sub = findSub(catId, subId);
            if (!sub) return;
            const verse = sub.verses.find(v => v.id === verseId);
            if (!verse) return;
            
            verse.attachments.splice(attIndex, 1);
            verse.lastModified = Date.now();
            saveData();
            render();
        }

        function setupDragAndDrop() {
            // Catégories
            const catHandles = document.querySelectorAll('.category-card .drag-handle');
            catHandles.forEach(handle => {
                const catDiv = handle.closest('.category-card');
                handle.setAttribute('draggable', 'true');
                
                handle.addEventListener('dragstart', (e) => {
                    draggedItem = { type: 'category', id: parseInt(catDiv.dataset.catId) };
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => catDiv.classList.add('dragging'), 0);
                });
                
                handle.addEventListener('dragend', () => {
                    catDiv.classList.remove('dragging');
                    draggedItem = null;
                });
                
                handle.addEventListener('touchstart', (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') e.preventDefault();
                    touchStartY = e.touches[0].clientY;
                    touchStartX = e.touches[0].clientX;
                    isDragging = true;
                    draggedItem = { type: 'category', id: parseInt(catDiv.dataset.catId) };
                    catDiv.classList.add('dragging');
                });
                
                handle.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    catDiv.classList.remove('dragging');
                    const touch = e.changedTouches[0];
                    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetCatDiv = dropTarget?.closest('.category-card');
                    if (targetCatDiv && draggedItem?.type === 'category') {
                        const fromId = draggedItem.id;
                        const toId = parseInt(targetCatDiv.dataset.catId);
                        if (fromId !== toId) {
                            const fromIdx = data.categories.findIndex(c => c.id === fromId);
                            const toIdx = data.categories.findIndex(c => c.id === toId);
                            if (fromIdx !== -1 && toIdx !== -1) {
                                const [moved] = data.categories.splice(fromIdx, 1);
                                data.categories.splice(toIdx, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                    draggedItem = null;
                    isDragging = false;
                });
            });
            
            const cats = document.querySelectorAll('.category-card');
            cats.forEach(catDiv => {
                catDiv.addEventListener('dragover', (e) => {
                    if (draggedItem?.type === 'category') {
                        e.preventDefault();
                    }
                });
                catDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedItem?.type === 'category') {
                        const fromId = draggedItem.id;
                        const toId = parseInt(catDiv.dataset.catId);
                        if (fromId !== toId) {
                            const fromIdx = data.categories.findIndex(c => c.id === fromId);
                            const toIdx = data.categories.findIndex(c => c.id === toId);
                            if (fromIdx !== -1 && toIdx !== -1) {
                                const [moved] = data.categories.splice(fromIdx, 1);
                                data.categories.splice(toIdx, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                });
            });

            // Sous-catégories
            const subHandles = document.querySelectorAll('.subcategory .drag-handle');
            subHandles.forEach(handle => {
                const subDiv = handle.closest('.subcategory');
                handle.setAttribute('draggable', 'true');
                
                handle.addEventListener('dragstart', (e) => {
                    draggedItem = {
                        type: 'subcategory',
                        catId: parseInt(subDiv.dataset.catId),
                        subId: parseInt(subDiv.dataset.subId),
                        path: subDiv.dataset.subPath,
                        level: parseInt(subDiv.dataset.level)
                    };
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => subDiv.classList.add('dragging'), 0);
                });
                
                handle.addEventListener('dragend', () => {
                    subDiv.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    draggedItem = null;
                });
                
                handle.addEventListener('touchstart', (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') e.preventDefault();
                    touchStartY = e.touches[0].clientY;
                    touchStartX = e.touches[0].clientX;
                    isDragging = true;
                    draggedItem = {
                        type: 'subcategory',
                        catId: parseInt(subDiv.dataset.catId),
                        subId: parseInt(subDiv.dataset.subId),
                        path: subDiv.dataset.subPath,
                        level: parseInt(subDiv.dataset.level)
                    };
                    subDiv.classList.add('dragging');
                });
                
                handle.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    subDiv.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    const touch = e.changedTouches[0];
                    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetSubDiv = dropTarget?.closest('.subcategory');
                    if (targetSubDiv && draggedItem?.type === 'subcategory') {
                        const toCatId = parseInt(targetSubDiv.dataset.catId);
                        const toPath = targetSubDiv.dataset.subPath;
                        const toLevel = parseInt(targetSubDiv.dataset.level);
                        if (draggedItem.catId === toCatId && draggedItem.level === toLevel && draggedItem.path !== toPath) {
                            const fromData = getSubcategoryByPath(draggedItem.catId, draggedItem.path);
                            const toData = getSubcategoryByPath(toCatId, toPath);
                            if (fromData && toData && fromData.parent === toData.parent) {
                                const [moved] = fromData.parent.splice(fromData.index, 1);
                                const adjustedIndex = fromData.index < toData.index ? toData.index : toData.index + 1;
                                fromData.parent.splice(adjustedIndex, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                    draggedItem = null;
                    isDragging = false;
                });
            });
            
            const subs = document.querySelectorAll('.subcategory');
            subs.forEach(subDiv => {
                subDiv.addEventListener('dragover', (e) => {
                    if (draggedItem?.type === 'subcategory') {
                        const targetCatId = parseInt(subDiv.dataset.catId);
                        const targetLevel = parseInt(subDiv.dataset.level);
                        if (draggedItem.catId === targetCatId && draggedItem.level === targetLevel) {
                            e.preventDefault();
                            subDiv.classList.add('drag-over');
                        }
                    }
                });
                subDiv.addEventListener('dragleave', () => {
                    subDiv.classList.remove('drag-over');
                });
                subDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    subDiv.classList.remove('drag-over');
                    if (draggedItem?.type === 'subcategory') {
                        const toCatId = parseInt(subDiv.dataset.catId);
                        const toPath = subDiv.dataset.subPath;
                        const toLevel = parseInt(subDiv.dataset.level);
                        if (draggedItem.catId === toCatId && draggedItem.level === toLevel && draggedItem.path !== toPath) {
                            const fromData = getSubcategoryByPath(draggedItem.catId, draggedItem.path);
                            const toData = getSubcategoryByPath(toCatId, toPath);
                            if (fromData && toData && fromData.parent === toData.parent) {
                                const [moved] = fromData.parent.splice(fromData.index, 1);
                                const adjustedIndex = fromData.index < toData.index ? toData.index : toData.index;
                                fromData.parent.splice(adjustedIndex, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                });
            });

            // Versets
            const verseHandles = document.querySelectorAll('.verse-item .drag-handle');
            verseHandles.forEach(handle => {
                const verseDiv = handle.closest('.verse-item');
                handle.setAttribute('draggable', 'true');
                
                handle.addEventListener('dragstart', (e) => {
                    draggedItem = {
                        type: 'verse',
                        catId: parseInt(verseDiv.dataset.catId),
                        subId: parseInt(verseDiv.dataset.subId),
                        verseId: parseInt(verseDiv.dataset.verseId),
                        index: parseInt(verseDiv.dataset.verseIndex)
                    };
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => verseDiv.classList.add('dragging'), 0);
                });
                
                handle.addEventListener('dragend', () => {
                    verseDiv.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    draggedItem = null;
                });
                
                handle.addEventListener('touchstart', (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') e.preventDefault();
                    touchStartY = e.touches[0].clientY;
                    touchStartX = e.touches[0].clientX;
                    isDragging = true;
                    draggedItem = {
                        type: 'verse',
                        catId: parseInt(verseDiv.dataset.catId),
                        subId: parseInt(verseDiv.dataset.subId),
                        verseId: parseInt(verseDiv.dataset.verseId),
                        index: parseInt(verseDiv.dataset.verseIndex)
                    };
                    verseDiv.classList.add('dragging');
                });
                
                handle.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    verseDiv.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    const touch = e.changedTouches[0];
                    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetVerseDiv = dropTarget?.closest('.verse-item');
                    if (targetVerseDiv && draggedItem?.type === 'verse') {
                        const toCatId = parseInt(targetVerseDiv.dataset.catId);
                        const toSubId = parseInt(targetVerseDiv.dataset.subId);
                        const toIndex = parseInt(targetVerseDiv.dataset.verseIndex);
                        if (draggedItem.catId === toCatId && draggedItem.subId === toSubId && draggedItem.index !== toIndex) {
                            const sub = findSub(toCatId, toSubId);
                            if (sub) {
                                const [moved] = sub.verses.splice(draggedItem.index, 1);
                                sub.verses.splice(toIndex, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                    draggedItem = null;
                    isDragging = false;
                });
            });
            
            const verses = document.querySelectorAll('.verse-item');
            verses.forEach(verseDiv => {
                verseDiv.addEventListener('dragover', (e) => {
                    if (draggedItem?.type === 'verse') {
                        const targetCatId = parseInt(verseDiv.dataset.catId);
                        const targetSubId = parseInt(verseDiv.dataset.subId);
                        if (draggedItem.catId === targetCatId && draggedItem.subId === targetSubId) {
                            e.preventDefault();
                            verseDiv.classList.add('drag-over');
                        }
                    }
                });
                verseDiv.addEventListener('dragleave', () => {
                    verseDiv.classList.remove('drag-over');
                });
                verseDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    verseDiv.classList.remove('drag-over');
                    if (draggedItem?.type === 'verse') {
                        const toCatId = parseInt(verseDiv.dataset.catId);
                        const toSubId = parseInt(verseDiv.dataset.subId);
                        const toIndex = parseInt(verseDiv.dataset.verseIndex);
                        if (draggedItem.catId === toCatId && draggedItem.subId === toSubId && draggedItem.index !== toIndex) {
                            const sub = findSub(toCatId, toSubId);
                            if (sub) {
                                const [moved] = sub.verses.splice(draggedItem.index, 1);
                                sub.verses.splice(toIndex, 0, moved);
                                saveData();
                                render();
                            }
                        }
                    }
                });
            });
        }

        function openJWVerse(ref) {
            const cleanRef = ref.trim().replace(/\s+/g, '+').replace(':', '%3A');
            const url = `https://www.jw.org/finder?wtlocale=F&bible=${encodeURIComponent(cleanRef)}`;
            window.open(url, '_blank');
        }

        // Initialisation
        loadLocalData();
    </script>
</body>
</html>
