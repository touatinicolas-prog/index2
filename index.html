<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon.png">
    
    <title>Mon Index Biblique</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --accent: #4a90e2;
            --border: #4a4a4a;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .header {
            background: var(--bg-secondary);
            padding: 20px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .header h1 { font-size: 22px; font-weight: 600; }
        .mode-toggle {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .search-input {
            width: 100%;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 12px;
        }
        .controls { display: flex; gap: 8px; flex-wrap: wrap; }
        .controls.hidden { display: none; }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            flex: 1;
            min-width: 100px;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-success { background: #2d7d46; color: white; }
        .btn-info { background: #357abd; color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); }
        .container { padding-bottom: 40px; }
        .category-card { background: var(--bg-secondary); border-bottom: 1px solid var(--border); }
        .category-card.dragging { opacity: 0.5; }
        .category-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .category-title-wrapper { display: flex; align-items: center; gap: 12px; flex: 1; }
        .category-title { font-size: 18px; font-weight: 600; }
        .drag-handle {
            cursor: grab;
            padding: 4px 8px;
            user-select: none;
            font-size: 18px;
        }
        .drag-handle:active { cursor: grabbing; }
        .icon-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 4px 8px;
        }
        .icon-btn.hidden { display: none; }
        .chevron { color: var(--text-secondary); font-size: 14px; }
        .category-content { display: none; background: var(--bg-primary); }
        .category-content.expanded { display: block; }
        .subcategory { 
            padding: 16px 20px 16px 40px; 
            border-bottom: 1px solid var(--border);
            position: relative;
        }
        .subcategory.level-2 { padding-left: 60px; }
        .subcategory.dragging { opacity: 0.5; }
        .subcategory.drag-over { border-top: 3px solid var(--accent); }
        .subcategory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .subcategory-title-wrapper { display: flex; align-items: center; gap: 10px; flex: 1; }
        .subcategory-title { font-size: 16px; font-weight: 500; color: var(--accent); }
        .subcategory-content { display: none; margin-top: 8px; }
        .subcategory-content.expanded { display: block; }
        .verse-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .verse-item.dragging { opacity: 0.5; }
        .verse-item.drag-over { border-top: 2px solid var(--accent); }
        .verse-content { flex: 1; display: flex; align-items: flex-start; gap: 8px; }
        .verse-ref {
            color: var(--accent);
            font-weight: 500;
            text-decoration: none;
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
        }
        .verse-note { color: var(--text-secondary); font-size: 14px; line-height: 1.5; white-space: pre-wrap; }
        .verse-attachments {
    margin-top: 10px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}
.attachment-thumb {
    width: 80px;
    height: 80px;
    border-radius: 6px;
    object-fit: cover;
    cursor: pointer;
    border: 2px solid var(--border);
    transition: border-color 0.2s;
}
.attachment-thumb:hover {
    border-color: var(--accent);
}
.attachment-pdf {
    width: 80px;
    height: 80px;
    border-radius: 6px;
    background: var(--bg-tertiary);
    border: 2px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    cursor: pointer;
    transition: border-color 0.2s;
}
.attachment-pdf:hover {
    border-color: var(--accent);
}
.file-input-wrapper {
    margin-top: 8px;
}
.file-input-label {
    display: inline-block;
    padding: 8px 16px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-primary);
    transition: background 0.2s;
}
.file-input-label:hover {
    background: var(--bg-primary);
}
.attached-files-list {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.attached-file-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    background: var(--bg-primary);
    border-radius: 6px;
}
.attached-file-preview {
    width: 50px;
    height: 50px;
    border-radius: 4px;
    object-fit: cover;
}
.attached-file-info {
    flex: 1;
    font-size: 14px;
    color: var(--text-secondary);
}
.attached-file-name {
    color: var(--text-primary);
    font-weight: 500;
}
.remove-file-btn {
    background: transparent;
    border: none;
    color: #e74c3c;
    cursor: pointer;
    font-size: 18px;
    padding: 4px;
}
.image-viewer-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    z-index: 2000;
    align-items: center;
    justify-content: center;
    padding: 20px;
}
.image-viewer-modal.show { display: flex; }
.image-viewer-content {
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;
}
.image-viewer-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: var(--bg-secondary);
    border: none;
    color: var(--text-primary);
    font-size: 32px;
    cursor: pointer;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}
        .highlight { background-color: #7a5d00; color: #fff; padding: 2px 4px; border-radius: 2px; }
        .context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            padding: 8px 0;
            z-index: 1000;
            min-width: 200px;
        }
        .context-menu-item { padding: 12px 16px; cursor: pointer; color: var(--text-primary); font-size: 15px; }
        .context-menu-item:active { background: var(--bg-tertiary); }
        .context-menu-item.danger { color: #e74c3c; }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }
        .modal.show { display: flex; }
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            border: 1px solid var(--border);
        }
        .modal-title { font-size: 20px; font-weight: 600; margin-bottom: 20px; }
        .form-group { margin-bottom: 16px; }
        .form-label { display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 14px; }
        .form-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 16px;
        }
.form-input:focus { outline: none; border-color: var(--accent); }
.form-textarea {
    display: none;
}
.rich-text-editor {
    width: 100%;
    padding: 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 16px;
    min-height: 120px;
    resize: vertical;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    line-height: 1.5;
    overflow-y: auto;
}
.rich-text-editor:focus { outline: none; border-color: var(--accent); }
.rich-text-editor:empty:before {
    content: attr(data-placeholder);
    color: var(--text-secondary);
    opacity: 0.5;
}
        .modal-buttons { display: flex; gap: 10px; margin-top: 24px; }
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        .splash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.3s;
        }
        .splash.hide { opacity: 0; pointer-events: none; }
        .splash-icon {
            width: 120px;
            height: 120px;
            background: var(--accent);
            border-radius: 27px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            margin-bottom: 20px;
        }
        .page-view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 200;
            overflow-y: auto;
        }
        .page-view.active { display: block; }
        .page-header {
            background: var(--bg-secondary);
            padding: 20px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 201;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .back-btn {
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .page-title {
            font-size: 20px;
            font-weight: 600;
            flex: 1;
        }
        .page-content { padding: 20px; }
        .formatting-toolbar {
    display: flex;
    gap: 4px;
    margin-bottom: 8px;
    padding: 8px;
    background: var(--bg-primary);
    border-radius: 6px;
    border: 1px solid var(--border);
    flex-wrap: wrap;
}
.format-btn {
    padding: 8px 14px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-primary);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
.format-btn:hover {
    background: var(--bg-secondary);
}
.format-btn:active {
    background: var(--accent);
    transform: scale(0.95);
}
.format-btn.active {
    background: var(--accent);
    border-color: var(--accent);
}
    </style>
</head>
    
<body>
    <div class="splash" id="splash">
        <div class="splash-icon">
            <img src="icon.png" alt="IB" style="width: 100%; height: 100%; border-radius: 27px;">
        </div>
        <div style="color: var(--text-secondary);">Mon Index Biblique</div>
    </div>
    
    <div class="header">
        <div class="header-top">
            <h1>Mon Index Biblique</h1>
            <button class="mode-toggle" onclick="toggleMode()" id="modeBtn">Mode Lecture</button>
        </div>
        <input type="text" class="search-input" id="searchInput" placeholder="Rechercher...">
        <div class="controls" id="controls">
            <button class="btn btn-primary" onclick="openModal('addCategoryModal')">+ Catégorie</button>
            <button class="btn btn-success" onclick="exportData()">Exporter</button>
            <button class="btn btn-secondary" onclick="checkStorageSize()">📊 Taille</button>
            <button class="btn btn-info" onclick="document.getElementById('importFile').click()">Importer</button>
            <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
        </div>
    </div>
    
    <div class="container">
        <div id="categoriesContainer"></div>
        <div class="empty-state" id="emptyState" style="display:none;">
            <h2>Aucune catégorie</h2>
            <p style="margin-top: 10px;">Cliquez sur "+ Catégorie" pour commencer</p>
        </div>
    </div>

    <div id="contextMenu"></div>
    
    <div class="modal" id="addCategoryModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Catégorie</div>
            <div class="form-group">
    <label class="form-label">Nom</label>
    <input type="text" class="form-input" id="categoryName" onkeypress="if(event.key==='Enter'){addCategory()}">
</div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="addCategory()">Ajouter</button>
                <button class="btn btn-secondary" onclick="closeModal('addCategoryModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="editCategoryModal">
        <div class="modal-content">
            <div class="modal-title">Modifier la catégorie</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
               <input type="text" class="form-input" id="editCategoryName" onkeypress="if(event.key==='Enter'){saveEditCategory()}">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="saveEditCategory()">Enregistrer</button>
                <button class="btn btn-secondary" onclick="closeModal('editCategoryModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addSubcategoryModal">
        <div class="modal-content">
            <div class="modal-title" id="subModalTitle">Nouvelle Sous-catégorie</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="subcategoryName" onkeypress="if(event.key==='Enter'){addSubcategory()}">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="addSubcategory()">Ajouter</button>
                <button class="btn btn-secondary" onclick="closeModal('addSubcategoryModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="editSubcategoryModal">
        <div class="modal-content">
            <div class="modal-title">Modifier</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="editSubcategoryName" onkeypress="if(event.key==='Enter'){saveEditSubcategory()}">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="saveEditSubcategory()">Enregistrer</button>
                <button class="btn btn-secondary" onclick="closeModal('editSubcategoryModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addVerseModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Verset</div>
            <div class="form-group">
                <label class="form-label">Référence</label>
                <input type="text" class="form-input" id="verseRef" onkeypress="if(event.key==='Enter'){document.getElementById('verseNote').focus()}">
            </div>
            <div class="form-group">
    <label class="form-label">Note</label>
    <div class="formatting-toolbar">
        <button type="button" class="format-btn" onclick="toggleFormat('verseNote', 'bold')" title="Gras"><strong>G</strong></button>
        <button type="button" class="format-btn" onclick="toggleFormat('verseNote', 'italic')" title="Italique"><em>I</em></button>
        <button type="button" class="format-btn" onclick="toggleFormat('verseNote', 'underline')" title="Souligné"><u>S</u></button>
    </div>
    <div class="rich-text-editor" id="verseNote" contenteditable="true" data-placeholder="Ajoutez vos réflexions, commentaires..." onkeydown="handleEditorKeydown(event, 'verseNote')"></div>
</div>
            <div class="form-group">
    <label class="form-label">Fichiers (images, PDF)</label>
    <div class="file-input-wrapper">
        <label class="file-input-label" for="verseFiles">📎 Ajouter des fichiers</label>
        <input type="file" id="verseFiles" accept="image/*,application/pdf" multiple style="display:none" onchange="handleFileSelect(event, 'add')">
    </div>
    <div id="addFilesPreview" class="attached-files-list"></div>
</div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="addVerse()">Ajouter</button>
                <button class="btn btn-secondary" onclick="closeModal('addVerseModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="editVerseModal">
        <div class="modal-content">
            <div class="modal-title">Modifier le verset</div>
            <div class="form-group">
                <label class="form-label">Référence</label>
                <input type="text" class="form-input" id="editVerseRef" onkeypress="if(event.key==='Enter'){document.getElementById('editVerseNote').focus()}">
            </div>
            <div class="form-group">
    <label class="form-label">Note</label>
    <div class="formatting-toolbar">
        <button type="button" class="format-btn" onclick="toggleFormat('editVerseNote', 'bold')" title="Gras"><strong>G</strong></button>
        <button type="button" class="format-btn" onclick="toggleFormat('editVerseNote', 'italic')" title="Italique"><em>I</em></button>
        <button type="button" class="format-btn" onclick="toggleFormat('editVerseNote', 'underline')" title="Souligné"><u>S</u></button>
    </div>
    <div class="rich-text-editor" id="editVerseNote" contenteditable="true" data-placeholder="Ajoutez vos réflexions, commentaires..." onkeydown="handleEditorKeydown(event, 'editVerseNote')"></div>
</div>
            <div class="form-group">
    <label class="form-label">Fichiers (images, PDF)</label>
    <div class="file-input-wrapper">
        <label class="file-input-label" for="editVerseFiles">📎 Ajouter des fichiers</label>
        <input type="file" id="editVerseFiles" accept="image/*,application/pdf" multiple style="display:none" onchange="handleFileSelect(event, 'edit')">
    </div>
    <div id="editFilesPreview" class="attached-files-list"></div>
</div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="saveEditVerse()">Enregistrer</button>
                <button class="btn btn-secondary" onclick="closeModal('editVerseModal')">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="mergeModal">
        <div class="modal-content">
            <div class="modal-title">🔄 Synchronisation des données</div>
            <p style="color: var(--text-secondary); line-height: 1.6; margin: 16px 0;">
                Voulez-vous <strong style="color: var(--text-primary);">fusionner</strong> les données avec celles existantes ?
            </p>
            <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin: 16px 0;">
                <div style="margin-bottom: 8px;">✅ <strong style="color: var(--text-primary);">OUI</strong> - Fusion intelligente (recommandé)</div>
                <div style="color: var(--text-secondary); font-size: 14px; margin-left: 24px;">Vos données actuelles seront conservées et combinées avec le fichier importé</div>
                <div style="margin: 12px 0 8px 0;">❌ <strong style="color: var(--text-primary);">NON</strong> - Remplacement total</div>
                <div style="color: var(--text-secondary); font-size: 14px; margin-left: 24px;">Toutes vos données actuelles seront remplacées</div>
            </div>
            <div class="modal-buttons" style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn btn-primary" onclick="confirmMerge(true)" style="flex: 1; min-width: 80px;">Oui</button>
                <button class="btn btn-secondary" onclick="confirmMerge(false)" style="flex: 1; min-width: 80px;">Non</button>
                <button class="btn btn-secondary" onclick="cancelImport()" style="flex: 1; min-width: 80px;">Annuler</button>
            </div>
        </div>
    </div>
    
    <div class="page-view" id="subsubPage">
        <div class="page-header">
            <button class="back-btn" onclick="closePage()">←</button>
            <div class="page-title" id="pageTitle"></div>
        </div>
        <div class="page-content" id="pageContent"></div>
    </div>
        <div class="image-viewer-modal" id="imageViewer" onclick="closeImageViewer()">
    <button class="image-viewer-close" onclick="closeImageViewer()">×</button>
    <img id="imageViewerContent" class="image-viewer-content" src="" alt="Image">
</div>

    <script>
        const STORAGE_KEY = 'monIndexBiblique';
        let data = {categories: [{id: 1, name: 'Foi et Confiance', expanded: true, lastModified: Date.now(), subcategories: [{id: 11, name: 'Renforcer sa foi', expanded: true, lastModified: Date.now(), verses: [{id: 111, ref: 'Hébreux 11:1', note: 'Définition de la foi', attachments: [], lastModified: Date.now()}], subcategories: []}]}]};
        let currentCat = null, currentSub = null, editItem = null, searchQuery = '', readOnlyMode = false;
        let dragMode = false, draggedItem = null;
        let tempAttachments = [];

        function loadData() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    data = JSON.parse(stored);
                }
            } catch (err) {
                console.error('Erreur lors du chargement des données:', err);
            }
        }

        function saveData() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (err) {
                console.error('Erreur lors de la sauvegarde des données:', err);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadData();
            render();
            setTimeout(() => document.getElementById('splash').classList.add('hide'), 1500);
            
            let timeout;
            document.getElementById('searchInput').addEventListener('input', (e) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    searchQuery = e.target.value.toLowerCase().trim();
                    render();
                }, 300);
            });
            document.addEventListener('click', closeContextMenu);
        });

        function closeContextMenu() {
            const existingMenus = document.querySelectorAll('.context-menu');
            existingMenus.forEach(menu => menu.remove());
        }

        function toggleMode() {
            readOnlyMode = !readOnlyMode;
            document.getElementById('modeBtn').textContent = readOnlyMode ? 'Mode Édition' : 'Mode Lecture';
            document.getElementById('controls').classList.toggle('hidden', readOnlyMode);
            if (readOnlyMode) dragMode = false;
            render();
        }

        function toggleDragMode() {
            dragMode = !dragMode;
            closeContextMenu();
            render();
        }

        function showMenu(e, items) {
    e.preventDefault();
    e.stopPropagation();
    
    closeContextMenu();
    
    const div = document.createElement('div');
    div.className = 'context-menu';
    
    items.forEach(item => {
        const itm = document.createElement('div');
        itm.className = 'context-menu-item' + (item.danger ? ' danger' : '');
        itm.textContent = item.label;
        itm.onclick = (ev) => {
            ev.stopPropagation();
            closeContextMenu();
            setTimeout(() => item.action(), 50);
        };
        div.appendChild(itm);
    });
    
    document.body.appendChild(div);
    
    setTimeout(() => {
        const rect = div.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Obtenir la position du clic en coordonnées viewport
        let x = e.clientX || (e.touches && e.touches[0].clientX) || 0;
        let y = e.clientY || (e.touches && e.touches[0].clientY) || 0;
        
        // Calculer la position X (éviter le débordement à droite)
        let finalX = x + 10;
        if (finalX + rect.width > viewportWidth - 10) {
            finalX = viewportWidth - rect.width - 10;
        }
        finalX = Math.max(10, finalX);
        
        // Calculer la position Y (afficher au-dessus si pas assez d'espace en-dessous)
        let finalY = y + 10;
        if (finalY + rect.height > viewportHeight - 10) {
            finalY = y - rect.height - 10;
        }
        // Si toujours pas assez d'espace, placer en haut de l'écran
        if (finalY < 10) {
            finalY = 10;
        }
        
        // Utiliser position fixed avec clientX/Y au lieu de pageX/Y
        div.style.left = finalX + 'px';
        div.style.top = finalY + 'px';
    }, 10);
}

        function highlight(text) {
            if (!searchQuery || !text) return text;
            const regex = new RegExp(`(${searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        function matches(text) {
    if (!text) return !searchQuery;
    // Nettoyer le HTML pour la recherche
    const cleanText = text.replace(/<[^>]*>/g, '').toLowerCase();
    return !searchQuery || cleanText.includes(searchQuery);
}

        function findSub(catId, subId, parentSubs = null) {
            const cat = data.categories.find(c => c.id === catId);
            if (!cat) return null;
            const subs = parentSubs || cat.subcategories;
            for (let sub of subs) {
                if (sub.id === subId) return sub;
                if (sub.subcategories?.length > 0) {
                    const found = findSub(catId, subId, sub.subcategories);
                    if (found) return found;
                }
            }
            return null;
        }

        function toggleCat(catId) {
            const cat = data.categories.find(c => c.id === catId);
            if (cat) { cat.expanded = !cat.expanded; render(); }
        }

        function toggleSub(catId, subId) {
            const sub = findSub(catId, subId);
            if (sub) { sub.expanded = !sub.expanded; render(); }
        }

        function renderSubs(subs, catId, level = 1, parentPath = '') {
    return subs.map((sub, idx) => {
        // Fonction récursive pour vérifier les matches dans toute la hiérarchie
        function hasMatchRecursive(subcategory) {
            // Vérifier le nom de la sous-catégorie
            if (matches(subcategory.name)) return true;
            
            // Vérifier les versets
            if (subcategory.verses && subcategory.verses.some(v => matches(v.ref) || matches(v.note || ''))) return true;
            
            // Vérifier récursivement les sous-sous-catégories
            if (subcategory.subcategories && subcategory.subcategories.length > 0) {
                return subcategory.subcategories.some(s => hasMatchRecursive(s));
            }
            
            return false;
        }
        
        const hasMatch = hasMatchRecursive(sub);
        if (!hasMatch && searchQuery) return '';
                const currentPath = parentPath ? `${parentPath}-${idx}` : `${idx}`;
                
                const onClickAction = level === 2 
                    ? `if(!dragMode)openSubsubPage(${catId}, ${sub.id})` 
                    : `if(!dragMode)toggleSub(${catId}, ${sub.id})`;
                
                return `<div class="subcategory ${level === 2 ? 'level-2' : ''}" data-cat-id="${catId}" data-sub-id="${sub.id}" data-sub-path="${currentPath}" data-level="${level}">
                    <div class="subcategory-header" onclick="${onClickAction}">
                        <div class="subcategory-title-wrapper">
                            ${dragMode ? '<span class="drag-handle" draggable="true">☰</span>' : ''}
                            <div class="subcategory-title">${highlight(sub.name)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:12px;">
                            <button class="icon-btn ${readOnlyMode ? 'hidden' : ''}" onclick="event.stopPropagation(); showSubMenu(event, ${catId}, ${sub.id}, ${level})">⋮</button>
                            ${level === 2 ? '<span class="chevron">→</span>' : `<span class="chevron">${sub.expanded ? '▼' : '▶'}</span>`}
                        </div>
                    </div>
                    ${level === 2 ? '' : `<div class="subcategory-content ${sub.expanded ? 'expanded' : ''}">
                        ${sub.subcategories?.length > 0 ? renderSubs(sub.subcategories, catId, level + 1, currentPath) : ''}
                        ${sub.verses.map((v, vIdx) => {
                            const vm = matches(v.ref) || matches(v.note || '');
                            if (!vm && searchQuery) return '';
                            return `<div class="verse-item" data-cat-id="${catId}" data-sub-id="${sub.id}" data-verse-id="${v.id}" data-verse-index="${vIdx}">
                                <div class="verse-content">
                                    ${dragMode ? '<span class="drag-handle" draggable="true">☰</span>' : ''}
                                    <div style="flex:1;">
    <div class="verse-ref">${highlight(v.ref)}</div>
    ${v.note ? `<div class="verse-note">${highlight(renderFormattedNote(v.note))}</div>` : ''}
    ${v.attachments && v.attachments.length > 0 ? `<div class="verse-attachments">${v.attachments.map((att, attIdx) => {
        if (att.type === 'application/pdf') {
            return `<div class="attachment-pdf" onclick="window.open('${att.data}', '_blank')">📄</div>`;
        } else {
            return `<img src="${att.data}" class="attachment-thumb" onclick="openImageViewer('${att.data}')" alt="Attachment ${attIdx + 1}">`;
        }
    }).join('')}</div>` : ''}
</div>
                                </div>
                                <button class="icon-btn ${readOnlyMode ? 'hidden' : ''}" onclick="event.stopPropagation(); showVerseMenu(event, ${catId}, ${sub.id}, ${v.id})">⋮</button>
                            </div>`;
                        }).join('')}
                    </div>`}
                </div>`;
            }).join('');
        }

        function openSubsubPage(catId, subId) {
            if (dragMode) return;
            
            const sub = findSub(catId, subId);
            if (!sub) return;
            
            if (document.getElementById('subsubPage').classList.contains('active')) return;
            
            document.getElementById('pageTitle').textContent = sub.name;
            
            const content = sub.verses.map((v, vIdx) => {
                return `<div class="verse-item" data-cat-id="${catId}" data-sub-id="${sub.id}" data-verse-id="${v.id}" data-verse-index="${vIdx}">
                    <div class="verse-content">
                        <div style="flex:1;">
    <div class="verse-ref">${v.ref}</div>
   ${v.note ? `<div class="verse-note">${renderFormattedNote(v.note)}</div>` : ''}
    ${v.attachments && v.attachments.length > 0 ? `<div class="verse-attachments">${v.attachments.map((att, attIdx) => {
        if (att.type === 'application/pdf') {
            return `<div class="attachment-pdf" onclick="window.open('${att.data}', '_blank')">📄</div>`;
        } else {
            return `<img src="${att.data}" class="attachment-thumb" onclick="openImageViewer('${att.data}')" alt="Attachment ${attIdx + 1}">`;
        }
    }).join('')}</div>` : ''}
</div>
                    </div>
                    <button class="icon-btn ${readOnlyMode ? 'hidden' : ''}" onclick="event.stopPropagation(); showVerseMenu(event, ${catId}, ${sub.id}, ${v.id})">⋮</button>
                </div>`;
            }).join('');
            
            document.getElementById('pageContent').innerHTML = content || '<div class="empty-state"><p>Aucun verset</p></div>';
            
            setTimeout(() => {
                document.getElementById('subsubPage').classList.add('active');
            }, 50);
        }

        function closePage() {
            document.getElementById('subsubPage').classList.remove('active');
        }

        function showCatMenu(e, catId) {
            showMenu(e, [
                { label: dragMode ? '✓ Réorganiser' : 'Réorganiser', action: () => toggleDragMode() },
                { label: '+ Sous-catégorie', action: () => openAddSubModal(catId) },
                { label: 'Modifier', action: () => openEditCatModal(catId) },
                { label: 'Supprimer', action: () => deleteCat(catId), danger: true }
            ]);
        }

        function showSubMenu(e, catId, subId, level) {
            const items = [{ label: dragMode ? '✓ Réorganiser' : 'Réorganiser', action: () => toggleDragMode() }];
            if (level < 2) items.push({ label: '+ Sous-sous-catégorie', action: () => openAddSubModal(catId, subId) });
            items.push(
                { label: '+ Verset', action: () => openAddVerseModal(catId, subId) },
                { label: 'Modifier', action: () => openEditSubModal(catId, subId) },
                { label: 'Supprimer', action: () => deleteSub(catId, subId), danger: true }
            );
            showMenu(e, items);
        }

     function showVerseMenu(e, catId, subId, verseId) {
    showMenu(e, [
        { label: dragMode ? '✓ Réorganiser' : 'Réorganiser', action: () => toggleDragMode() },
        { label: 'Modifier', action: () => openEditVerseModal(catId, subId, verseId) },
        { label: 'Supprimer', action: () => deleteVerse(catId, subId, verseId), danger: true }
    ]);
}

function render() {
    const container = document.getElementById('categoriesContainer');
    if (data.categories.length === 0) {
        container.innerHTML = '';
        document.getElementById('emptyState').style.display = 'block';
        return;
    }
    document.getElementById('emptyState').style.display = 'none';
    container.innerHTML = data.categories.map((cat, idx) => {
        const hasMatch = matches(cat.name) || cat.subcategories.some(s => matches(s.name) || s.verses.some(v => matches(v.ref) || matches(v.note || '')));
        if (!hasMatch && searchQuery) return '';
        return `<div class="category-card" data-cat-index="${idx}" data-cat-id="${cat.id}">
            <div class="category-header" onclick="if(!dragMode)toggleCat(${cat.id})">
                <div class="category-title-wrapper">
                    ${dragMode ? '<span class="drag-handle" draggable="true">☰</span>' : ''}
                    <div class="category-title">${highlight(cat.name)}</div>
                </div>
                <div style="display:flex;align-items:center;gap:12px;">
                    <button class="icon-btn ${readOnlyMode ? 'hidden' : ''}" onclick="event.stopPropagation(); showCatMenu(event, ${cat.id})">⋮</button>
                    <span class="chevron">${cat.expanded ? '▼' : '▶'}</span>
                </div>
            </div>
            <div class="category-content ${cat.expanded ? 'expanded' : ''}">
                ${renderSubs(cat.subcategories, cat.id)}
            </div>
        </div>`;
    }).join('');
    
    if (dragMode) setupDragDrop();
}

function openModal(id) { 
    document.getElementById(id).classList.add('show'); 
    // Focus automatique sur le premier champ de saisie
    setTimeout(() => {
        const modal = document.getElementById(id);
        const firstInput = modal.querySelector('input[type="text"], textarea');
        if (firstInput) firstInput.focus();
    }, 100);
}
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

function getSubcategoryByPath(catId, path) {
    const cat = data.categories.find(c => c.id === catId);
    if (!cat) return null;
    
    const indices = path.split('-').map(n => parseInt(n));
    let current = cat.subcategories;
    let parent = cat.subcategories;
    
    for (let i = 0; i < indices.length; i++) {
        const idx = indices[i];
        if (!current[idx]) return null;
        
        if (i === indices.length - 1) {
            return { parent: parent, index: idx, item: current[idx] };
        } else {
            parent = current[idx].subcategories;
            current = current[idx].subcategories;
        }
    }
    return null;
}

function setupDragDrop() {
    let touchStartY = 0;
    let touchStartX = 0;
    let isDragging = false;
    
    // Catégories
    const catHandles = document.querySelectorAll('.category-card > .category-header .drag-handle');
    catHandles.forEach(handle => {
        const card = handle.closest('.category-card');
        
        // Desktop drag & drop
        handle.setAttribute('draggable', 'true');
        
        handle.addEventListener('dragstart', (e) => {
            draggedItem = { 
                type: 'category', 
                index: parseInt(card.dataset.catIndex)
            };
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => card.classList.add('dragging'), 0);
        });
        
        handle.addEventListener('dragend', () => {
            card.classList.remove('dragging');
            draggedItem = null;
        });
        
        // Mobile touch events
        handle.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = true;
            draggedItem = { 
                type: 'category', 
                index: parseInt(card.dataset.catIndex)
            };
            card.classList.add('dragging');
        });
        
        handle.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            card.classList.remove('dragging');
            
            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetCard = dropTarget?.closest('.category-card');
            
            if (targetCard && draggedItem?.type === 'category') {
                const toIndex = parseInt(targetCard.dataset.catIndex);
                const fromIndex = draggedItem.index;
                if (fromIndex !== toIndex) {
                    const [moved] = data.categories.splice(fromIndex, 1);
                    data.categories.splice(toIndex, 0, moved);
                    saveData();
                    render();
                }
            }
            
            draggedItem = null;
            isDragging = false;
        });
    });
    
    const cats = document.querySelectorAll('.category-card');
    cats.forEach(card => {
        card.addEventListener('dragover', (e) => {
            if (draggedItem?.type === 'category') {
                e.preventDefault();
            }
        });
        
        card.addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedItem?.type === 'category') {
                const toIndex = parseInt(card.dataset.catIndex);
                const fromIndex = draggedItem.index;
                if (fromIndex !== toIndex) {
                    const [moved] = data.categories.splice(fromIndex, 1);
                    data.categories.splice(toIndex, 0, moved);
                    saveData();
                    render();
                }
            }
        });
    });

    // Sous-catégories
    const subHandles = document.querySelectorAll('.subcategory > .subcategory-header .drag-handle');
    subHandles.forEach(handle => {
        const subDiv = handle.closest('.subcategory');
        
        // Desktop drag & drop
        handle.setAttribute('draggable', 'true');
        
        handle.addEventListener('dragstart', (e) => {
            draggedItem = { 
                type: 'subcategory', 
                catId: parseInt(subDiv.dataset.catId),
                path: subDiv.dataset.subPath,
                level: parseInt(subDiv.dataset.level)
            };
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => subDiv.classList.add('dragging'), 0);
        });
        
        handle.addEventListener('dragend', () => {
            subDiv.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            draggedItem = null;
        });
        
        // Mobile touch events
        handle.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = true;
            draggedItem = { 
                type: 'subcategory', 
                catId: parseInt(subDiv.dataset.catId),
                path: subDiv.dataset.subPath,
                level: parseInt(subDiv.dataset.level)
            };
            subDiv.classList.add('dragging');
        });
        
        handle.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            subDiv.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            
            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetSubDiv = dropTarget?.closest('.subcategory');
            
            if (targetSubDiv && draggedItem?.type === 'subcategory') {
                const toCatId = parseInt(targetSubDiv.dataset.catId);
                const toPath = targetSubDiv.dataset.subPath;
                const toLevel = parseInt(targetSubDiv.dataset.level);
                
                if (draggedItem.catId === toCatId && draggedItem.level === toLevel && draggedItem.path !== toPath) {
                    const fromData = getSubcategoryByPath(draggedItem.catId, draggedItem.path);
                    const toData = getSubcategoryByPath(toCatId, toPath);
                    
                    if (fromData && toData && fromData.parent === toData.parent) {
                        const [moved] = fromData.parent.splice(fromData.index, 1);
                        const adjustedIndex = fromData.index < toData.index ? toData.index : toData.index;
                        fromData.parent.splice(adjustedIndex, 0, moved);
                        saveData();
                        render();
                    }
                }
            }
            
            draggedItem = null;
            isDragging = false;
        });
    });
    
    const subs = document.querySelectorAll('.subcategory');
    subs.forEach(subDiv => {
        subDiv.addEventListener('dragover', (e) => {
            if (draggedItem?.type === 'subcategory') {
                const targetCatId = parseInt(subDiv.dataset.catId);
                const targetLevel = parseInt(subDiv.dataset.level);
                if (draggedItem.catId === targetCatId && draggedItem.level === targetLevel) {
                    e.preventDefault();
                    subDiv.classList.add('drag-over');
                }
            }
        });
        
        subDiv.addEventListener('dragleave', () => {
            subDiv.classList.remove('drag-over');
        });
        
        subDiv.addEventListener('drop', (e) => {
            e.preventDefault();
            subDiv.classList.remove('drag-over');
            
            if (draggedItem?.type === 'subcategory') {
                const toCatId = parseInt(subDiv.dataset.catId);
                const toPath = subDiv.dataset.subPath;
                const toLevel = parseInt(subDiv.dataset.level);
                
                if (draggedItem.catId === toCatId && draggedItem.level === toLevel && draggedItem.path !== toPath) {
                    const fromData = getSubcategoryByPath(draggedItem.catId, draggedItem.path);
                    const toData = getSubcategoryByPath(toCatId, toPath);
                    
                    if (fromData && toData && fromData.parent === toData.parent) {
                        const [moved] = fromData.parent.splice(fromData.index, 1);
                        const adjustedIndex = fromData.index < toData.index ? toData.index : toData.index;
                        fromData.parent.splice(adjustedIndex, 0, moved);
                        saveData();
                        render();
                    }
                }
            }
        });
    });

    // Versets
    const verseHandles = document.querySelectorAll('.verse-item .drag-handle');
    verseHandles.forEach(handle => {
        const verseDiv = handle.closest('.verse-item');
        
        // Desktop drag & drop
        handle.setAttribute('draggable', 'true');
        
        handle.addEventListener('dragstart', (e) => {
            draggedItem = {
                type: 'verse',
                catId: parseInt(verseDiv.dataset.catId),
                subId: parseInt(verseDiv.dataset.subId),
                verseId: parseInt(verseDiv.dataset.verseId),
                index: parseInt(verseDiv.dataset.verseIndex)
            };
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => verseDiv.classList.add('dragging'), 0);
        });
        
        handle.addEventListener('dragend', () => {
            verseDiv.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            draggedItem = null;
        });
        
        // Mobile touch events
        handle.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = true;
            draggedItem = {
                type: 'verse',
                catId: parseInt(verseDiv.dataset.catId),
                subId: parseInt(verseDiv.dataset.subId),
                verseId: parseInt(verseDiv.dataset.verseId),
                index: parseInt(verseDiv.dataset.verseIndex)
            };
            verseDiv.classList.add('dragging');
        });
        
        handle.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            verseDiv.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            
            const touch = e.changedTouches[0];
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetVerseDiv = dropTarget?.closest('.verse-item');
            
            if (targetVerseDiv && draggedItem?.type === 'verse') {
                const toCatId = parseInt(targetVerseDiv.dataset.catId);
                const toSubId = parseInt(targetVerseDiv.dataset.subId);
                const toIndex = parseInt(targetVerseDiv.dataset.verseIndex);
                
                if (draggedItem.catId === toCatId && draggedItem.subId === toSubId && draggedItem.index !== toIndex) {
                    const sub = findSub(toCatId, toSubId);
                    if (sub) {
                        const [moved] = sub.verses.splice(draggedItem.index, 1);
                        sub.verses.splice(toIndex, 0, moved);
                        saveData();
                        render();
                    }
                }
            }
            
            draggedItem = null;
            isDragging = false;
        });
    });
    
    const verses = document.querySelectorAll('.verse-item');
    verses.forEach(verseDiv => {
        verseDiv.addEventListener('dragover', (e) => {
            if (draggedItem?.type === 'verse') {
                const targetCatId = parseInt(verseDiv.dataset.catId);
                const targetSubId = parseInt(verseDiv.dataset.subId);
                if (draggedItem.catId === targetCatId && draggedItem.subId === targetSubId) {
                    e.preventDefault();
                    verseDiv.classList.add('drag-over');
                }
            }
        });
        
        verseDiv.addEventListener('dragleave', () => {
            verseDiv.classList.remove('drag-over');
        });
        
        verseDiv.addEventListener('drop', (e) => {
            e.preventDefault();
            verseDiv.classList.remove('drag-over');
            
            if (draggedItem?.type === 'verse') {
                const toCatId = parseInt(verseDiv.dataset.catId);
                const toSubId = parseInt(verseDiv.dataset.subId);
                const toIndex = parseInt(verseDiv.dataset.verseIndex);
                
                if (draggedItem.catId === toCatId && draggedItem.subId === toSubId && draggedItem.index !== toIndex) {
                    const sub = findSub(toCatId, toSubId);
                    if (sub) {
                        const [moved] = sub.verses.splice(draggedItem.index, 1);
                        sub.verses.splice(toIndex, 0, moved);
                        saveData();
                        render();
                    }
                }
            }
        });
    });
}

function addCategory() {
    const name = document.getElementById('categoryName').value.trim();
    if (!name) return;
    data.categories.push({ id: Date.now(), name, expanded: true, subcategories: [], lastModified: Date.now() });
    saveData();
    render();
    closeModal('addCategoryModal');
    document.getElementById('categoryName').value = '';
}

function openEditCatModal(catId) {
    editItem = { type: 'cat', id: catId };
    const cat = data.categories.find(c => c.id === catId);
    document.getElementById('editCategoryName').value = cat.name;
    openModal('editCategoryModal');
}

function saveEditCategory() {
    const cat = data.categories.find(c => c.id === editItem.id);
    if (cat) { 
        cat.name = document.getElementById('editCategoryName').value.trim(); 
        cat.lastModified = Date.now();
        saveData(); 
        render(); 
    }
    closeModal('editCategoryModal');
}

function openAddSubModal(catId, parentSubId = null) {
    currentCat = catId;
    currentSub = parentSubId;
    document.getElementById('subcategoryName').value = '';
    document.getElementById('subModalTitle').textContent = parentSubId ? 'Nouvelle Sous-sous-catégorie' : 'Nouvelle Sous-catégorie';
    openModal('addSubcategoryModal');
}

function addSubcategory() {
    const name = document.getElementById('subcategoryName').value.trim();
    if (!name) return;
    if (currentSub) {
        const parentSub = findSub(currentCat, currentSub);
        if (parentSub) {
            if (!parentSub.subcategories) parentSub.subcategories = [];
            parentSub.subcategories.push({ id: Date.now(), name, expanded: true, verses: [], subcategories: [], lastModified: Date.now() });
            parentSub.lastModified = Date.now();
        }
    } else {
        const cat = data.categories.find(c => c.id === currentCat);
        if (cat) {
            cat.subcategories.push({ id: Date.now(), name, expanded: true, verses: [], subcategories: [], lastModified: Date.now() });
            cat.lastModified = Date.now();
        }
    }
    saveData();
    render();
    closeModal('addSubcategoryModal');
}

function openEditSubModal(catId, subId) {
    editItem = { type: 'sub', catId, id: subId };
    const sub = findSub(catId, subId);
    if (sub) {
        document.getElementById('editSubcategoryName').value = sub.name;
        openModal('editSubcategoryModal');
    }
}

function saveEditSubcategory() {
    const sub = findSub(editItem.catId, editItem.id);
    if (sub) { 
        sub.name = document.getElementById('editSubcategoryName').value.trim(); 
        sub.lastModified = Date.now();
        saveData(); 
        render(); 
    }
    closeModal('editSubcategoryModal');
}

function openAddVerseModal(catId, subId) {
    currentCat = catId;
    currentSub = subId;
    document.getElementById('verseRef').value = '';
    document.getElementById('verseNote').innerHTML = '';
    document.getElementById('verseFiles').value = '';
    document.getElementById('addFilesPreview').innerHTML = '';
    tempAttachments = [];
    openModal('addVerseModal');
}

function addVerse() {
    const ref = document.getElementById('verseRef').value.trim();
    const noteHTML = document.getElementById('verseNote').innerHTML.trim();
    const note = noteHTML.replace(/<br\s*\/?>/gi, '\n');
    if (!ref) return;
    const sub = findSub(currentCat, currentSub);
    if (sub) { 
        sub.verses.push({ 
            id: Date.now(), 
            ref, 
            note, 
            attachments: [...tempAttachments],
            lastModified: Date.now()
        });
        sub.lastModified = Date.now();
        saveData(); 
        render(); 
    }
    closeModal('addVerseModal');
    tempAttachments = [];
}

function openEditVerseModal(catId, subId, verseId) {
    editItem = { type: 'verse', catId, subId, id: verseId };
    const sub = findSub(catId, subId);
    if (sub) {
        const verse = sub.verses.find(v => v.id === verseId);
        if (verse) {
            document.getElementById('editVerseRef').value = verse.ref;
            const noteHTML = (verse.note || '').replace(/\n/g, '<br>');
            document.getElementById('editVerseNote').innerHTML = noteHTML;
            document.getElementById('editVerseFiles').value = '';
            tempAttachments = verse.attachments ? [...verse.attachments] : [];
            displayEditAttachments();
            openModal('editVerseModal');
        }
    }
}

function saveEditVerse() {
    const sub = findSub(editItem.catId, editItem.subId);
    if (sub) {
        const verse = sub.verses.find(v => v.id === editItem.id);
        if (verse) {
            verse.ref = document.getElementById('editVerseRef').value.trim();
            const noteHTML = document.getElementById('editVerseNote').innerHTML.trim();
            verse.note = noteHTML.replace(/<br\s*\/?>/gi, '\n');
            verse.attachments = [...tempAttachments];
            verse.lastModified = Date.now();
            sub.lastModified = Date.now();
            saveData();
            render();
        }
    }
    closeModal('editVerseModal');
    tempAttachments = [];
}

function deleteCat(catId) {
    if (confirm('Supprimer cette catégorie ?')) {
        data.categories = data.categories.filter(c => c.id !== catId);
        saveData();
        render();
    }
}

function deleteSubRec(subs, subId) {
    for (let i = 0; i < subs.length; i++) {
        if (subs[i].id === subId) { subs.splice(i, 1); return true; }
        if (subs[i].subcategories?.length > 0 && deleteSubRec(subs[i].subcategories, subId)) return true;
    }
    return false;
}

function deleteSub(catId, subId) {
    if (confirm('Supprimer cette sous-catégorie ?')) {
        const cat = data.categories.find(c => c.id === catId);
        if (cat) { deleteSubRec(cat.subcategories, subId); saveData(); render(); }
    }
}

function deleteVerse(catId, subId, verseId) {
    const sub = findSub(catId, subId);
    if (sub) { sub.verses = sub.verses.filter(v => v.id !== verseId); saveData(); render(); }
}

function exportData() {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `index-biblique-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
}

        function checkStorageSize() {
    try {
        const jsonString = JSON.stringify(data);
        const sizeInBytes = jsonString.length;
        const sizeInKB = (sizeInBytes / 1024).toFixed(2);
        const sizeInMB = (sizeInBytes / 1024 / 1024).toFixed(2);
        const percentUsed = ((sizeInBytes / (5 * 1024 * 1024)) * 100).toFixed(1);
        
        // Fonction récursive pour compter les fichiers
        function countFilesRecursive(subcategories) {
            let imgCount = 0;
            let pdfCountLocal = 0;
            
            subcategories.forEach(sub => {
                // Compter dans les versets de cette sous-catégorie
                if (sub.verses) {
                    sub.verses.forEach(v => {
                        if (v.attachments) {
                            v.attachments.forEach(att => {
                                if (att.type.startsWith('image/')) imgCount++;
                                if (att.type === 'application/pdf') pdfCountLocal++;
                            });
                        }
                    });
                }
                // Récursion pour les sous-sous-catégories
                if (sub.subcategories && sub.subcategories.length > 0) {
                    const subCounts = countFilesRecursive(sub.subcategories);
                    imgCount += subCounts.images;
                    pdfCountLocal += subCounts.pdfs;
                }
            });
            
            return { images: imgCount, pdfs: pdfCountLocal };
        }
        
        // Compter tous les fichiers
        let imageCount = 0;
        let pdfCount = 0;
        
        data.categories.forEach(cat => {
            const counts = countFilesRecursive(cat.subcategories);
            imageCount += counts.images;
            pdfCount += counts.pdfs;
        });
        
        alert(`📊 INFORMATIONS DE STOCKAGE\n\n` +
              `Taille: ${sizeInKB} KB (${sizeInMB} MB)\n` +
              `Utilisation: ${percentUsed}% de la limite\n` +
              `Limite navigateur: ~5 MB\n\n` +
              `📎 Fichiers attachés:\n` +
              `Images: ${imageCount}\n` +
              `PDF: ${pdfCount}\n\n` +
              `${percentUsed > 80 ? '⚠️ ATTENTION: Proche de la limite !' : '✅ Espace suffisant'}`);
    } catch (err) {
        alert('❌ Erreur lors du calcul de la taille');
        console.error(err);
    }
}
        
let pendingImportData = null;

function importData(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                pendingImportData = JSON.parse(ev.target.result);
                openModal('mergeModal');
            } catch (err) {
                alert('❌ Erreur lors de l\'import');
                console.error(err);
            }
        };
        reader.readAsText(file);
    }
}

function confirmMerge(shouldMerge) {
    closeModal('mergeModal');
    
    try {
        if (shouldMerge) {
            mergeData(pendingImportData);
            console.log('Fusion terminée');
        } else {
            data = JSON.parse(JSON.stringify(pendingImportData));
            console.log('Remplacement terminé');
        }
        
        // Calculer la taille des données
        const jsonString = JSON.stringify(data);
        const sizeInMB = (jsonString.length / 1024 / 1024).toFixed(2);
        console.log(`Taille des données: ${sizeInMB} MB`);
        
        // Vérifier si la taille est raisonnable (< 4 MB pour être sûr)
        if (jsonString.length > 4 * 1024 * 1024) {
            throw new Error(`Les données sont trop volumineuses (${sizeInMB} MB). La limite du navigateur est d'environ 5 MB.\n\nConseil: Réduisez le nombre d'images ou leur qualité.`);
        }
        
        // Tenter la sauvegarde
        localStorage.setItem(STORAGE_KEY, jsonString);
        console.log('✅ Sauvegarde réussie');
        
        // Vérification
        const verification = localStorage.getItem(STORAGE_KEY);
        if (!verification) {
            throw new Error('La sauvegarde a échoué - vérification impossible');
        }
        
        // Recharger depuis le localStorage
        data = JSON.parse(verification);
        render();
        
        alert(shouldMerge ? 
            `✅ Données fusionnées avec succès !\n\nTaille: ${sizeInMB} MB` : 
            `✅ Données remplacées avec succès !\n\nTaille: ${sizeInMB} MB`);
            
    } catch (err) {
        console.error('❌ Erreur:', err);
        
        // Message spécifique pour quota dépassé
        if (err.name === 'QuotaExceededError' || err.message.includes('quota')) {
            const sizeInMB = (JSON.stringify(data).length / 1024 / 1024).toFixed(2);
            alert(`❌ QUOTA DÉPASSÉ !\n\nVos données (${sizeInMB} MB) dépassent la limite du navigateur (~5 MB).\n\n💡 Solutions:\n1. Réduisez le nombre d'images attachées\n2. Compressez vos images avant de les ajouter\n3. Utilisez moins de fichiers PDF\n4. Exportez régulièrement vos données en plusieurs fichiers`);
        } else {
            alert('❌ Erreur lors de l\'import:\n\n' + err.message);
        }
        
        // Restaurer les données précédentes
        try {
            const oldData = localStorage.getItem(STORAGE_KEY);
            if (oldData) {
                data = JSON.parse(oldData);
                render();
            }
        } catch (restoreErr) {
            console.error('Impossible de restaurer les anciennes données');
        }
    }
    
    pendingImportData = null;
    document.getElementById('importFile').value = '';
}

function cancelImport() {
    closeModal('mergeModal');
    pendingImportData = null;
    document.getElementById('importFile').value = ''; // Réinitialise le sélecteur de fichier
}

function mergeData(importedData) {
    if (!importedData.categories) return;
    
    // Parcourir toutes les catégories importées
    importedData.categories.forEach(importedCat => {
        const existingCat = data.categories.find(c => c.id === importedCat.id);
        
        if (existingCat) {
            // La catégorie existe déjà, fusionner
            mergeCategoryData(existingCat, importedCat);
        } else {
            // Nouvelle catégorie, l'ajouter
            data.categories.push(importedCat);
        }
    });
}

function mergeCategoryData(existing, imported) {
    // Mettre à jour si la version importée est plus récente
    if (imported.lastModified && (!existing.lastModified || imported.lastModified > existing.lastModified)) {
        existing.name = imported.name;
        existing.lastModified = imported.lastModified;
    }
    
    // Fusionner les sous-catégories
    if (imported.subcategories) {
        if (!existing.subcategories) existing.subcategories = [];
        
        imported.subcategories.forEach(importedSub => {
            const existingSub = findSubInArray(existing.subcategories, importedSub.id);
            
            if (existingSub) {
                mergeSubcategoryData(existingSub, importedSub);
            } else {
                existing.subcategories.push(importedSub);
            }
        });
    }
}

function mergeSubcategoryData(existing, imported) {
    // Mettre à jour si la version importée est plus récente
    if (imported.lastModified && (!existing.lastModified || imported.lastModified > existing.lastModified)) {
        existing.name = imported.name;
        existing.lastModified = imported.lastModified;
    }
    
    // Fusionner les versets
    if (imported.verses) {
        if (!existing.verses) existing.verses = [];
        
        imported.verses.forEach(importedVerse => {
            const existingVerse = existing.verses.find(v => v.id === importedVerse.id);
            
            if (existingVerse) {
                // Le verset existe, garder la version la plus récente
                if (importedVerse.lastModified && (!existingVerse.lastModified || importedVerse.lastModified > existingVerse.lastModified)) {
                    existingVerse.ref = importedVerse.ref;
                    existingVerse.note = importedVerse.note;
                    existingVerse.attachments = importedVerse.attachments;
                    existingVerse.lastModified = importedVerse.lastModified;
                }
            } else {
                // Nouveau verset, l'ajouter
                existing.verses.push(importedVerse);
            }
        });
    }
    
    // Fusionner les sous-sous-catégories
    if (imported.subcategories) {
        if (!existing.subcategories) existing.subcategories = [];
        
        imported.subcategories.forEach(importedSubSub => {
            const existingSubSub = findSubInArray(existing.subcategories, importedSubSub.id);
            
            if (existingSubSub) {
                mergeSubcategoryData(existingSubSub, importedSubSub);
            } else {
                existing.subcategories.push(importedSubSub);
            }
        });
    }
}

function findSubInArray(subsArray, subId) {
    for (let sub of subsArray) {
        if (sub.id === subId) return sub;
        if (sub.subcategories?.length > 0) {
            const found = findSubInArray(sub.subcategories, subId);
            if (found) return found;
        }
    }
    return null;
}
        
        function handleFileSelect(event, mode) {
    const files = event.target.files;
    if (!files.length) return;
    
    Array.from(files).forEach(file => {
        // Si c'est un PDF, pas de compression
        if (file.type === 'application/pdf') {
            const reader = new FileReader();
            reader.onload = (e) => {
                const attachment = {
                    name: file.name,
                    type: file.type,
                    data: e.target.result
                };
                tempAttachments.push(attachment);
                if (mode === 'add') {
                    displayAddAttachments();
                } else {
                    displayEditAttachments();
                }
            };
            reader.readAsDataURL(file);
        } 
        // Si c'est une image, compresser
        else if (file.type.startsWith('image/')) {
            compressImage(file, (compressedData) => {
                const attachment = {
                    name: file.name,
                    type: file.type,
                    data: compressedData
                };
                tempAttachments.push(attachment);
                if (mode === 'add') {
                    displayAddAttachments();
                } else {
                    displayEditAttachments();
                }
            });
        }
    });
}

function compressImage(file, callback) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            
            // Définir la largeur maximale (1200px est un bon compromis)
            const MAX_WIDTH = 1200;
            const MAX_HEIGHT = 1200;
            
            let width = img.width;
            let height = img.height;
            
            // Calculer les nouvelles dimensions en gardant le ratio
            if (width > height) {
                if (width > MAX_WIDTH) {
                    height = height * (MAX_WIDTH / width);
                    width = MAX_WIDTH;
                }
            } else {
                if (height > MAX_HEIGHT) {
                    width = width * (MAX_HEIGHT / height);
                    height = MAX_HEIGHT;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Convertir en JPEG avec qualité 0.8 (bon compromis qualité/taille)
            const compressedData = canvas.toDataURL('image/jpeg', 0.8);
            
            // Calculer la réduction
            const originalSize = e.target.result.length;
            const compressedSize = compressedData.length;
            const reduction = ((1 - compressedSize / originalSize) * 100).toFixed(0);
            
            console.log(`📸 Image compressée: ${file.name}`);
            console.log(`   Original: ${(originalSize / 1024).toFixed(1)} KB`);
            console.log(`   Compressé: ${(compressedSize / 1024).toFixed(1)} KB`);
            console.log(`   Réduction: ${reduction}%`);
            
            callback(compressedData);
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function displayAddAttachments() {
    const container = document.getElementById('addFilesPreview');
    container.innerHTML = tempAttachments.map((att, idx) => {
        const isImage = att.type.startsWith('image/');
        const isPdf = att.type === 'application/pdf';
        const sizeKB = (att.data.length / 1024).toFixed(1);
        return `<div class="attached-file-item">
            ${isImage ? `<img src="${att.data}" class="attached-file-preview" alt="${att.name}">` : 
              isPdf ? `<div class="attached-file-preview" style="background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 20px;">📄</div>` : ''}
            <div class="attached-file-info">
                <div class="attached-file-name">${att.name}</div>
                <div>${sizeKB} KB ${isImage ? '✓ compressé' : ''}</div>
            </div>
            <button class="remove-file-btn" onclick="removeAttachment(${idx}, 'add')">×</button>
        </div>`;
    }).join('');
}

function displayEditAttachments() {
    const container = document.getElementById('editFilesPreview');
    container.innerHTML = tempAttachments.map((att, idx) => {
        const isImage = att.type.startsWith('image/');
        const isPdf = att.type === 'application/pdf';
        const sizeKB = (att.data.length / 1024).toFixed(1);
        return `<div class="attached-file-item">
            ${isImage ? `<img src="${att.data}" class="attached-file-preview" alt="${att.name}">` : 
              isPdf ? `<div class="attached-file-preview" style="background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 20px;">📄</div>` : ''}
            <div class="attached-file-info">
                <div class="attached-file-name">${att.name}</div>
                <div>${sizeKB} KB ${isImage ? '✓ compressé' : ''}</div>
            </div>
            <button class="remove-file-btn" onclick="removeAttachment(${idx}, 'edit')">×</button>
        </div>`;
    }).join('');
}

function removeAttachment(index, mode) {
    tempAttachments.splice(index, 1);
    if (mode === 'add') {
        displayAddAttachments();
    } else {
        displayEditAttachments();
    }
}

function openImageViewer(src) {
    document.getElementById('imageViewerContent').src = src;
    document.getElementById('imageViewer').classList.add('show');
}

function closeImageViewer() {
    document.getElementById('imageViewer').classList.remove('show');
}
        let currentFormatState = {
    bold: false,
    italic: false,
    underline: false
};

function toggleFormat(editorId, format) {
    const editor = document.getElementById(editorId);
    editor.focus();
    
    // Activer/désactiver le format
    if (format === 'bold') {
        document.execCommand('bold', false, null);
    } else if (format === 'italic') {
        document.execCommand('italic', false, null);
    } else if (format === 'underline') {
        document.execCommand('underline', false, null);
    }
    
    // Mettre à jour l'état visuel du bouton
    updateFormatButtons(editorId);
}

function updateFormatButtons(editorId) {
    const toolbar = document.getElementById(editorId).previousElementSibling;
    if (!toolbar || !toolbar.classList.contains('formatting-toolbar')) return;
    
    const buttons = toolbar.querySelectorAll('.format-btn');
    buttons.forEach(btn => {
        const title = btn.getAttribute('title');
        if (title === 'Gras') {
            btn.classList.toggle('active', document.queryCommandState('bold'));
        } else if (title === 'Italique') {
            btn.classList.toggle('active', document.queryCommandState('italic'));
        } else if (title === 'Souligné') {
            btn.classList.toggle('active', document.queryCommandState('underline'));
        }
    });
}

function handleEditorKeydown(event, editorId) {
    // Ctrl+Enter pour soumettre
    if (event.key === 'Enter' && event.ctrlKey) {
        event.preventDefault();
        if (editorId === 'verseNote') {
            addVerse();
        } else if (editorId === 'editVerseNote') {
            saveEditVerse();
        }
        return;
    }
    
    // Mettre à jour les boutons après un court délai pour que le formatage soit appliqué
    setTimeout(() => updateFormatButtons(editorId), 10);
}

// Mettre à jour les boutons quand on clique dans l'éditeur
document.addEventListener('DOMContentLoaded', () => {
    ['verseNote', 'editVerseNote'].forEach(editorId => {
        const editor = document.getElementById(editorId);
        if (editor) {
            editor.addEventListener('mouseup', () => updateFormatButtons(editorId));
            editor.addEventListener('keyup', () => updateFormatButtons(editorId));
            editor.addEventListener('touchend', () => updateFormatButtons(editorId));
        }
    });
});


function renderFormattedNote(note) {
    if (!note) return '';
    // Le HTML est déjà formaté depuis contenteditable
    return note.replace(/\n/g, '<br>');
}
    </script>
</body>
</html>
